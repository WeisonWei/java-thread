# Thread

## 相关概念
1. Java虚拟机的内存结构
2. Java内存模型
3. CPU三级缓存
3. CPU指令
4. 可见性 
5. 指令重排序

### 1 Java虚拟机内存结构
堆、栈、方法
> [Java虚拟机内存结构](https://www.cnblogs.com/aflyun/p/10575740.html)
### 2 Java内存模型
保证多线程之间操作共享变量的正确性
### 3 CPU缓存
CPU L1|--总线--|L2 L3|内存 三级缓存
### 4 CPU指令
通常一条指令包括两方面的内容：操作码和操作数，操作码决定要完成的操作，操作数指参加运算的数据及其所在的单元地址。
操作要求和操作数地址都由二进制数码表示，分别称作操作码和地址码，整条指令以二进制编码的形式存放在存储器中。
### 5 可见性
可见性存在与多核CPU的情况下，所以，也可以说是多核CPU之间的数据可见性；
强内存模型:相同地址都各个CPU能看到；
弱内存模型:不同CPU之间存在内存屏障(memory barriers),需要通过执行指令将缓存中数据同步至内存中其它CPU才能看到；

实现可见性:
1.刷新CPU缓存的数据到内存中，保证这个写操作能够被其它CPU可见;
2.将CPU缓存的数据设置为无效状态，保证其它CPU的写操作对本CPU可见。
> 内存屏障，除了实现CPU之前的数据可见性之外，还有一个重要的职责，可以禁止指令的重排序。
### 6 指令重排序
这里说的重排序可以发生在好几个地方：编译器、运行时、JIT等，比如编译器会觉得把一个变量的写操作放在最后会更有效率，
编译后，这个指令就在最后了（前提是只要不改变程序的语义，编译器、执行器就可以这样自由的随意优化），
一旦编译器对某个变量的写操作进行优化（放到最后），那么在执行之前，另一个线程将不会看到这个执行结果。

## synchronized
1)互斥功能
2)对于后续进入该代码块的线程是可见的（又是可见性，不过这里需要注意是对同一个monitor对象而言）
3)它还有一个语义是禁止指令的重排序，对于编译器来说，同步块中的代码不会移动到获取和释放monitor外面

## final
1)final修饰字段，可保证可见性
2)final修饰字段，禁止指令重排序

> 在对象的构造过程中，不允许对该对象进行引用，不然的话，可能存在其它线程在对象还没构造完成时就对该对象进行访问。
## volatile
1)volatile修饰字段，每次写操作后，都会同步至内存中，可保证可见性
2)volatile修饰字段处代码被禁止重排序


> 参考:[Java内存模型](https://www.jianshu.com/p/bf158fbb2432)